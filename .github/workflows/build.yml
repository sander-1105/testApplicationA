name: Build and Version Management

on:
  push:
    branches:
      - main
    paths:
      - '**'
  pull_request:
    branches:
      - main
    paths:
      - '**'
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  pre-check:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      current_version: ${{ steps.read_version.outputs.current_version }}
      new_version: ${{ steps.read_version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Version Check
        id: read_version
        run: |
          if [ ! -f "VERSION" ]; then
            echo "Error: VERSION file not found"
            exit 1
          fi
          
          # Check if this is the first commit
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            if [[ $(git diff --name-only HEAD~1 HEAD) == *"VERSION"* ]]; then
              echo "Version file changed, proceeding with build"
            else
              echo "No version change, but proceeding with build for other file changes"
            fi
          else
            echo "First commit detected, proceeding with build"
          fi
          
          VERSION_LINE=$(grep "export VERSION=" VERSION)
          if [ -z "$VERSION_LINE" ]; then
            echo "Error: VERSION line not found in VERSION file"
            exit 1
          fi
          
          VERSION=$(echo "$VERSION_LINE" | cut -d'=' -f2)
          if [ -z "$VERSION" ]; then
            echo "Error: Could not extract version number"
            exit 1
          fi
          
          NEW_VERSION=$(echo $VERSION | awk -F. '{$2 = $2 + 1;} 1' | sed 's/ /./g')
          
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

  chart-validation:
    needs: pre-check
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.base_ref == 'main')
    env:
      NEW_VERSION: ${{ needs.pre-check.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Setup SSH
        run: |
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY secret not found"
            exit 1
          fi
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          chmod 700 ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
          # Test SSH connection
          ssh -T git@github.com || true

      - name: Install yq
        run: |
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq

      - name: Validate Chart Repository Access
        run: |
          # Read helm-chart-ssh-url from ci.yml
          HELM_CHART_SSH_URL=$(yq e '.helm-chart-ssh-url' ci.yml)
          if [ -z "$HELM_CHART_SSH_URL" ]; then
            echo "Error: helm-chart-ssh-url not found in ci.yml"
            exit 1
          fi
          
          # Extract repository name from URL
          REPO_NAME=$(basename "$HELM_CHART_SSH_URL" .git)
          echo "Repository name: $REPO_NAME"
          
          # Clone chart repository
          git clone "$HELM_CHART_SSH_URL" chart-temp
          cd chart-temp
          
          # Ensure we're on main branch
          git checkout main
          
          # Validate Chart.yaml
          if [ ! -f "Chart.yaml" ]; then
            echo "Error: Chart.yaml not found"
            exit 1
          fi
          
          # Read current appVersion
          CURRENT_VERSION=$(yq e '.appVersion' Chart.yaml)
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Error: Could not read appVersion from Chart.yaml"
            exit 1
          fi
          
          echo "Chart validation successful"
          echo "Current appVersion: $CURRENT_VERSION"
          echo "New appVersion will be: $NEW_VERSION"

  version-update:
    needs: [pre-check, chart-validation]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.base_ref == 'main')
    env:
      CURRENT_VERSION: ${{ needs.pre-check.outputs.current_version }}
      NEW_VERSION: ${{ needs.pre-check.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Update version file
        run: |
          if ! sed -i.bak "s/export VERSION=.*/export VERSION=${{ env.NEW_VERSION }}/" VERSION; then
            echo "Error: Failed to update VERSION file"
            exit 1
          fi
          rm -f VERSION.bak
          
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions@github.com'
          
          # Ensure we're on main branch
          git checkout main
          
          git add VERSION
          git commit -m "Bump version to ${{ env.NEW_VERSION }}"
          git push origin main

      - name: Create and push tag
        run: |
          git tag -a "v${{ env.NEW_VERSION }}" -m "Release version ${{ env.NEW_VERSION }}"
          git push origin "v${{ env.NEW_VERSION }}"

  docker-build:
    needs: [pre-check, version-update]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.base_ref == 'main')
    env:
      NEW_VERSION: ${{ needs.pre-check.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Install Task
        uses: arduino/setup-task@v2
        with:
          version: 3.x
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image using Task
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVICE_ACCOUNT_BASE64_FILE: ${{ secrets.SERVICE_ACCOUNT_BASE64_FILE }}
        run: |
          task docker:build

  chart-update:
    needs: [pre-check, version-update, docker-build]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.base_ref == 'main')
    env:
      NEW_VERSION: ${{ needs.pre-check.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Setup SSH
        run: |
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY secret not found"
            exit 1
          fi
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          chmod 700 ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          ssh-keyscan gitlab.com >> ~/.ssh/known_hosts

      - name: Install yq
        run: |
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq

      - name: Update App A Chart Repository
        run: |
          # Read helm-chart-ssh-url from ci.yml
          HELM_CHART_SSH_URL=$(yq e '.helm-chart-ssh-url' ci.yml)
          if [ -z "$HELM_CHART_SSH_URL" ]; then
            echo "Error: helm-chart-ssh-url not found in ci.yml"
            exit 1
          fi
          
          # Extract repository name from URL
          REPO_NAME=$(basename "$HELM_CHART_SSH_URL" .git)
          echo "Repository name: $REPO_NAME"
          
          # Clone chart repository
          git clone "$HELM_CHART_SSH_URL"
          cd "$REPO_NAME"
          
          # Ensure we're on main branch
          git checkout main
          
          # Check if Chart.yaml exists
          if [ ! -f "Chart.yaml" ]; then
            echo "Error: Chart.yaml not found"
            exit 1
          fi
          
          # Check if values.yaml exists
          if [ ! -f "values.yaml" ]; then
            echo "Error: values.yaml not found"
            exit 1
          fi
          
          # Read current appVersion
          CURRENT_VERSION=$(yq e '.appVersion' Chart.yaml)
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Error: Could not read appVersion from Chart.yaml"
            exit 1
          fi
          
          # Read current imageTag
          CURRENT_IMAGE_TAG=$(yq e '.imageTag' values.yaml)
          echo "Current imageTag: $CURRENT_IMAGE_TAG"
          
          # Update appVersion in Chart.yaml
          yq e -i ".appVersion = \"$NEW_VERSION\"" Chart.yaml
          if [ $? -ne 0 ]; then
            echo "Error: Failed to update appVersion in Chart.yaml"
            exit 1
          fi
          
          # Update imageTag in values.yaml
          yq e -i ".imageTag = \"$NEW_VERSION\"" values.yaml
          if [ $? -ne 0 ]; then
            echo "Error: Failed to update imageTag in values.yaml"
            exit 1
          fi
          
          # Verify the updates
          echo "Verifying updates..."
          echo "New appVersion in Chart.yaml: $(yq e '.appVersion' Chart.yaml)"
          echo "New imageTag in values.yaml: $(yq e '.imageTag' values.yaml)"
          
          # Commit and push changes
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@github.com"
          git add .
          git commit -m "Update Chart appVersion to $NEW_VERSION and imageTag to $NEW_VERSION"
          git push origin main 