name: Build and Version Management

on:
  push:
    branches:
      - main
    paths:
      - '**'
  pull_request:
    branches:
      - main
    paths:
      - '**'
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  version-check:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'synchronize')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Version Check
        run: |
          if [ ! -f "VERSION" ]; then
            echo "Error: VERSION file not found"
            exit 1
          fi
          
          # Check if this is the first commit
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            if [[ $(git diff --name-only HEAD~1 HEAD) == *"VERSION"* ]]; then
              echo "Version file changed, proceeding with build"
            else
              echo "No version change, skipping build"
              exit 0
            fi
          else
            echo "First commit detected, proceeding with build"
          fi

  setup:
    needs: version-check
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}

  version-update:
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read current version
        id: read_version
        run: |
          if [ ! -f "VERSION" ]; then
            echo "Error: VERSION file not found"
            exit 1
          fi
          
          VERSION_LINE=$(grep "export VERSION=" VERSION)
          if [ -z "$VERSION_LINE" ]; then
            echo "Error: VERSION line not found in VERSION file"
            exit 1
          fi
          
          VERSION=$(echo "$VERSION_LINE" | cut -d'=' -f2)
          if [ -z "$VERSION" ]; then
            echo "Error: Could not extract version number"
            exit 1
          fi
          
          echo "CURRENT_VERSION=$VERSION" >> $GITHUB_ENV
          echo "NEW_VERSION=$(echo $VERSION | awk -F. '{$2 = $2 + 1;} 1' | sed 's/ /./g')" >> $GITHUB_ENV

      - name: Update version file
        run: |
          if ! sed -i.bak "s/export VERSION=.*/export VERSION=${{ env.NEW_VERSION }}/" VERSION; then
            echo "Error: Failed to update VERSION file"
            exit 1
          fi
          rm -f VERSION.bak
          
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions@github.com'
          
          # Checkout the correct branch
          git checkout -B ${{ github.ref_name }}
          
          git add VERSION
          git commit -m "Bump version to ${{ env.NEW_VERSION }}"
          git push origin ${{ github.ref_name }}

      - name: Create and push tag
        run: |
          git tag -a "v${{ env.NEW_VERSION }}" -m "Release version ${{ env.NEW_VERSION }}"
          git push origin "v${{ env.NEW_VERSION }}"

  chart-update:
    needs: version-update
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          ssh-keyscan gitlab.com >> ~/.ssh/known_hosts

      - name: Update App A Chart Repository
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            try {
              // Read helm-chart-ssh-url from ci.yml
              const ciYaml = yaml.load(fs.readFileSync('ci.yml', 'utf8'));
              const helmChartSshUrl = ciYaml['helm-chart-ssh-url'];
              
              if (!helmChartSshUrl) {
                throw new Error('helm-chart-ssh-url not found in ci.yml');
              }
              
              // Clone app-a-chart repository using SSH URL from ci.yml
              execSync(`git clone ${helmChartSshUrl}`);
              process.chdir('app-a-chart');
              
              // Read chart.yaml
              if (!fs.existsSync('Chart.yaml')) {
                throw new Error('Chart.yaml not found');
              }
              
              const chart = yaml.load(fs.readFileSync('Chart.yaml', 'utf8'));
              if (!chart) {
                throw new Error('Failed to parse Chart.yaml');
              }
              
              // Update appVersion
              chart.appVersion = process.env.NEW_VERSION;
              
              // Write back to file
              fs.writeFileSync('Chart.yaml', yaml.dump(chart));
              
              // Commit and push changes
              execSync('git config --global user.name "GitHub Actions"');
              execSync('git config --global user.email "github-actions@github.com"');
              execSync('git add Chart.yaml');
              execSync('git commit -m "Update Chart appVersion to ' + process.env.NEW_VERSION + '"');
              execSync('git push');
            } catch (error) {
              core.setFailed(`Failed to update chart: ${error.message}`);
            }

  notification:
    needs: [version-update, chart-update]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: always()
    permissions:
      issues: write
      contents: read
    steps:
      - name: Notify on status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const status = context.job === 'notification' ? 'completed' : 'failed';
              const title = `Build ${status}`;
              const body = `Build ${status} for commit: ${context.sha}\n\nWorkflow: ${context.workflow}\nRun ID: ${context.runId}`;
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body
              });
            } catch (error) {
              console.error('Failed to create issue:', error.message);
              // Don't fail the workflow if notification fails
            }

# 使用更细粒度的权限
permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

env:
  NODE_ENV: production
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true 